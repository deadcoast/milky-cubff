# Blaise Agüera y Arcas’ BFF Experiment (Self-Replicating Brainfuck Programs)

## Background and Goals

Blaise Agüera y Arcas and colleagues conducted a “primordial soup” simulation using an extended Brainfuck language (dubbed BFF) to explore the spontaneous emergence of self-replicating programs[emergentmind.com](https://www.emergentmind.com/papers/2406.19108#:~:text=,replication%20even%20in%20deterministic%20settings). The goal was to observe digital life-like behavior – i.e. whether complex self-replicating code can arise from random code interactions alone (without any explicit fitness function or seeded replicator). This research sits at the intersection of artificial life and computing, demonstrating how _purposeful_ code (a reproducing program) can emerge _out of randomness_ under the right conditions[emergentmind.com](https://www.emergentmind.com/papers/2406.19108#:~:text=,replication%20even%20in%20deterministic%20settings).

## The BFF “Primordial Soup” Simulation

In the BFF experiment, the “organisms” are simply 64-byte programs (initially filled with random bytes). The system maintains a large population (e.g. 1000 programs) in a _soup_. These programs interact by random concatenation and execution. The workflow can be summarized as follows:

1. Select two programs at random from the soup (call them A and B, each 64 bytes).
2. Concatenate A and B to form a combined 128-byte tape (A+B).
3. Execute the combined program A+B. (In BFF, execution is _self-modifying_: the running code can overwrite parts of the tape, including what came from A or B.)[arxiv.org](https://arxiv.org/pdf/2406.19108?#:~:text=it%20onerous%20for%20humans%20to,as%20one%20byte%20per%20pointer)
4. Split the modified tape back into two 64-byte halves, which become the new versions of A and B.
5. Return A and B to the soup, replacing their old versions.
6. Repeat this process indefinitely (millions of random pair interactions).

Early on, almost all random bytes are non-opcodes (no-ops) in this Brainfuck-derived language, so most interactions do nothing noticeable. You might occasionally see a byte change here or there due to a random effect. However, after a great many iterations (on the order of millions of pairings), a remarkable transition occurs: one of the programs evolves into a self-replicator and quickly spreads[nautil.us](https://nautil.us/in-the-beginning-there-was-computation-787023/#:~:text=interactions%2C%20imperfect%20replicators%20begin%20competing%2C,of%20its%20original%20architecture%20indefinitely)[emergentmind.com](https://www.emergentmind.com/papers/2406.19108#:~:text=self,interactions%20are%20the%20primary%20contributors). In Blaise’s description, initially the soup’s content is essentially _incompressible noise_, but then suddenly the system’s entropy drops – the data becomes highly _compressible_, signaling emergent structure/patterns[emergentmind.com](https://www.emergentmind.com/papers/2406.19108#:~:text=self,interactions%20are%20the%20primary%20contributors). In other words, a complex program appears that can make copies of itself, and it begins to populate many tapes in the soup. Once a true self-replicator arises, it has a huge advantage: whenever it interacts with another program, it copies itself onto the other tape, propagating its code. Very quickly the replicator (or its variants) take over a large fraction of the soup. This spontaneous emergence of a reproducing program _“from nothing”_ is analogous to a form of digital abiogenesis.

## The BFF Language (Extended Brainfuck)

Brainfuck (BF) is an esoteric minimalistic programming language with only 8 simple commands (>, <, +, -, ., ,, [, ]). In standard BF, there is a separate instruction pointer (traversing the code) and a data pointer (traversing an array of memory cells), plus I/O streams for input `,` and output `.`. For the experiment, the researchers extended Brainfuck into “BFF” to create a self-contained, self-modifying universe[arxiv.org](https://arxiv.org/pdf/2406.19108?#:~:text=it%20onerous%20for%20humans%20to,as%20one%20byte%20per%20pointer). The key changes in BFF are:

- Unified code and data tape: Instead of separate program and data memory, BFF uses one tape that holds the bytes of the program itself. The instruction pointer, data pointer, and a second pointer all operate on this single tape[arxiv.org](https://arxiv.org/pdf/2406.19108?#:~:text=it%20onerous%20for%20humans%20to,as%20one%20byte%20per%20pointer). This means a running program can modify its own code (since code = data here). Essentially, the program can write to the same tape from which it’s being read, enabling self-alteration and replication of code.
- Two pointers (“heads”): BFF introduces a second data pointer. In the paper, they refer to head0 and head1[arxiv.org](https://arxiv.org/pdf/2406.19108?#:~:text=input%20and%20output%20streams%20with,instruction%20set%20is%20as%20follows). The `<` and `>` commands move head0 (like the data pointer in normal BF), while `{` and `}` were added to move head1 (these curly-brace instructions are new in BFF)[arxiv.org](https://arxiv.org/pdf/2406.19108?#:~:text=%3C%20head0%20%3D%20head0%20,command).
- No external I/O: The `.` and `,` instructions (output and input in BF) are repurposed as copy operations between the two pointers. In BFF, `.` copies the byte at head0 to the position at head1, and `,` copies from head1 to head0[arxiv.org](https://arxiv.org/pdf/2406.19108?#:~:text=,command). This effectively lets a program copy bytes from one location to another on the tape (facilitating replication).
- The loop constructs `[` and `]` remain as conditional jumps (they form loops exactly as in normal Brainfuck)[arxiv.org](https://arxiv.org/pdf/2406.19108?#:~:text=,command). Any byte value that doesn’t correspond to a defined instruction is treated as a no-op (harmlessly ignored)[arxiv.org](https://arxiv.org/pdf/2406.19108?#:~:text=input%20and%20output%20streams%20with,instruction%20set%20is%20as%20follows).

These extensions (two movable heads and self-modifying tape) allow BFF programs to act like simple _machines that can read and write on their own “genome.”_ When two tapes are concatenated and run, they essentially can copy segments of code from one half to the other. A successful self-replicator that evolves in this system will leverage these operations to duplicate its byte sequence onto another tape. In fact, once evolved, the “purpose” of each byte in the replicator becomes clear – if you flip a critical byte, the program fails to copy itself and loses its only function (its _purpose_), which is analogous to killing the digital organism (a point Blaise emphasizes in talks).

## Emergence of Self-Replicating Programs

Over many random interactions, typically _nothing happens_ – most random programs do not reproduce or perform any meaningful computation. However, in some runs a critical transition occurs: imperfect self-copiers appear first, followed by a fully formed self-replicating program. The moment of transition is marked by a steep drop in the system’s entropy and a rapid increase in structured activity[emergentmind.com](https://www.emergentmind.com/papers/2406.19108#:~:text=self,interactions%20are%20the%20primary%20contributors). In one run described by Agüera y Arcas, a few primitive copy routines appeared around ~2 million interactions, chaotically copying fragments (creating short-lived “chimeras”), and then around ~5.6 million interactions a symbiotic whole-tape replicator suddenly emerged[nautil.us](https://nautil.us/in-the-beginning-there-was-computation-787023/#:~:text=lineages%20to%20the%20original%20,of%20its%20original%20architecture%20indefinitely). Once a true replicator is present, it outcompetes other code: it copies itself onto other tapes, so that more and more tapes in the soup contain the replicator. Soon the majority of the 1000 tapes become identical or slight variations of the replicator. In experimental terms, the system undergoes a phase transition from a “pre-life” state (no self-replicating programs) to a “life” state dominated by self-replicators[emergentmind.com](https://www.emergentmind.com/papers/2406.19108#:~:text=self,Spatial%20and%20Long%20Tape%20Simulations). Notably, this happened without any explicit selection criteria or fitness function – the only driver was the intrinsic advantage of a program that can make copies of itself.

The evolved programs in BFF were found to be complex and nontrivial. The researchers had to reverse-engineer some of them to understand how they work. Interestingly, multiple distinct self-replicating sequences (different “species”) can sometimes emerge and compete. In a spatial variant of the experiment (placing programs on a 2D grid with local interactions), they observed waves of replicators spreading and occasionally coexisting with others[arxiv.org](https://arxiv.org/pdf/2406.19108?#:~:text=Figure%208%3A%20A%20part%20of,replicators)[arxiv.org](https://arxiv.org/pdf/2406.19108?#:~:text=and%20the%20accompanying%20YouTube%20video2,replicators%20evolve%20and). This shows the richness of dynamics: beyond the first replicator, more complex behaviors like parasitism, symbiosis, or variations of replicators can evolve over time (paralleling biological evolution).

## Implementation and Source Code

The BFF experiment has been implemented in open-source code, so it’s available for inspection and use. The primary codebase (called “CuBFF”) is hosted on GitHub[github.com](https://github.com/paradigms-of-intelligence/cubff#:~:text=CuBFF). It is written in C++ with Python bindings, and can optionally leverage CUDA for GPU acceleration (useful to run millions of interactions faster)[github.com](https://github.com/paradigms-of-intelligence/cubff#:~:text=This%20project%20provides%20a%20,were%20done%20using%20this%20code). The repository provides a command-line tool to run simulations; for example, after compiling, one can run a primordial soup simulation with the BFF language by executing: `bin/main --lang bff_noheads`[github.com](https://github.com/paradigms-of-intelligence/cubff#:~:text=CuBFF). (The “noheads” variant refers to one configuration of the BFF language used in the paper.) The code supports several language variants and experimental settings mentioned in the study[arxiv.org](https://arxiv.org/pdf/2406.19108?#:~:text=The%20code%20for%20the%20experiments,lang%20bff_noheads).

> Code reference: _Agüera y Arcas et al. explicitly provide the source code used in their paper. The repository `paradigms-of-intelligence/cubff` contains the implementation of the self-modifying soup and was used for most experiments in the “Computational Life” paper[github.com](https://github.com/paradigms-of-intelligence/cubff#:~:text=CuBFF). The code supports both CPU and GPU execution and includes implementations of BFF and other toy languages from the study[arxiv.org](https://arxiv.org/pdf/2406.19108?#:~:text=The%20code%20for%20the%20experiments,lang%20bff_noheads)._

Additionally, one of the co-authors (Ben Laurie) has provided a Go implementation for certain experiments (available in the `benlaurie/bff-ben` repository)[arxiv.org](https://arxiv.org/pdf/2406.19108?#:~:text=detail%2C%20we%20release%20its%20code,for%20a%20different%20programming%20language), including a visualization tool called `bfsoup` for observing the soup’s evolution. These resources mean that if you are building your own system, you can study and reuse the existing implementations as a starting point rather than coding everything from scratch.

## Other Experiments and Related Work

Blaise’s BFF experiment is not an isolated case – the team extended their investigations to other languages and drew on prior work in digital evolution:

- Other languages in the same study: Agüera y Arcas et al. showed that the emergence of self-replicating programs is _not limited to Brainfuck_. They repeated the primordial-soup simulation with a simplified Forth (stack-based language) and even with actual machine-code instruction sets (emulating a Z80 and 8080 CPU). In these cases, self-replicators also emerged spontaneously[emergentmind.com](https://www.emergentmind.com/papers/2406.19108#:~:text=specifically%20primordial%20soup%20simulations%2C%20spatial,were%20not%20observed%20to%20emerge). For example, in a Z80 simulation, they observed multiple “waves” of replicators, with later replicators evolving to use more efficient instructions (like the Z80’s block memory copy instruction `LDIR`) to reproduce faster[emergentmind.com](https://www.emergentmind.com/papers/2406.19108#:~:text=self,Counterexample%20with%20SUBLEQ). This suggests that several computational substrates – from high-level languages to real assembly – can support spontaneous digital life, as long as they allow self-modification or copying. On the other hand, the team found a counterexample: using an extremely minimal one-instruction language (SUBLEQ, a subtract-and-branch language) did _not_ yield any replicators in their tests[emergentmind.com](https://www.emergentmind.com/papers/2406.19108#:~:text=4.%20Counterexample%20with%20SUBLEQ%3A%20,spontaneous%20emergence%20via%20random%20interactions). The likely reason is that in SUBLEQ the shortest possible self-replicating program is relatively long and complex, making it astronomically unlikely to appear at random[emergentmind.com](https://www.emergentmind.com/papers/2406.19108#:~:text=4.%20Counterexample%20with%20SUBLEQ%3A%20,spontaneous%20emergence%20via%20random%20interactions). This underscores that not _every_ computational universe is equally fertile for life; certain minimal conditions (like enough instructions to copy data and perform loops) must be in place[nautil.us](https://nautil.us/in-the-beginning-there-was-computation-787023/#:~:text=There%20are%20irreducible%20requirements%2C%20though%3A,%E2%80%9D)[arxiv.org](https://arxiv.org/pdf/2406.19108?#:~:text=it%20onerous%20for%20humans%20to,as%20one%20byte%20per%20pointer).

- Earlier digital life research: The BFF experiment builds on a lineage of artificial life experiments. In the early 1990s, Thomas Ray’s Tierra and later the Avida platform (by Ofria et al.) were designed to study evolving programs. However, those systems started with at least one hand-written self-replicating program as an ancestor in the environment[arxiv.org](https://arxiv.org/pdf/2406.19108?#:~:text=computation%20increases%20a%20replicator%E2%80%99s%20allotted,into%20%E2%80%9Clife%E2%80%9D%20dynamics%2C%20but%20still). Once seeded, evolution would act on those digital organisms (they could mutate, compete, and even produce parasites and co-evolve). By contrast, the BFF experiment begins with _no_ self-replicators – everything is random – and demonstrates the _origin_ of self-replication. There have also been theoretical “computational chemistry” models of emergent replication. For instance, Walter Fontana in the mid-1990s simulated random interactions of lambda calculus expressions, and observed that a trivial self-replicator (the identity function) could emerge and take over the system[arxiv.org](https://arxiv.org/pdf/2406.19108?#:~:text=a%20very%20simple%20solution%20involves,is%20explicitly%20disallowed%20by%20constraint). That was essentially a digital analog of a simple autocatalytic molecule. Blaise’s work pushes this further by showing _non-trivial, complex_ replicators can appear in simple Turing-complete languages without any intelligent design.

In summary, Agüera y Arcas’ BFF experiment provides concrete, actionable evidence of how life-like programs can spontaneously arise in a computational medium. For researchers or hobbyists interested in building their own such system, the key takeaways are: ensure the language/environment allows programs to store and copy information (self-modify), set up a method for programs to randomly interact and execute each other, and then run a large population for many iterations. The open-source code from the BFF study is an excellent reference implementation[github.com](https://github.com/paradigms-of-intelligence/cubff#:~:text=CuBFF). This line of research is ongoing – by experimenting with different rule-sets or initial conditions, one can explore the boundary between non-life and life in silico, and possibly discover new forms of artificial self-replication and open-ended evolution[emergentmind.com](https://www.emergentmind.com/papers/2406.19108#:~:text=behaviors%20even%20without%20predefined%20fitness,of%20evolving%20complex%20behaviors%20autonomously)[emergentmind.com](https://www.emergentmind.com/papers/2406.19108#:~:text=elements%20play%20a%20crucial%20role,still%20achieve%20significant%20evolutionary%20dynamics).

Sources:

- Agüera y Arcas, B. _et al._ “Computational Life: How Well-formed, Self-replicating Programs Emerge from Simple Interaction.” arXiv preprint 2406.19108 (2024)[emergentmind.com](https://www.emergentmind.com/papers/2406.19108#:~:text=specifically%20primordial%20soup%20simulations%2C%20spatial,were%20not%20observed%20to%20emerge)[emergentmind.com](https://www.emergentmind.com/papers/2406.19108#:~:text=self,Counterexample%20with%20SUBLEQ)[arxiv.org](https://arxiv.org/pdf/2406.19108?#:~:text=it%20onerous%20for%20humans%20to,as%20one%20byte%20per%20pointer)[arxiv.org](https://arxiv.org/pdf/2406.19108?#:~:text=computation%20increases%20a%20replicator%E2%80%99s%20allotted,into%20%E2%80%9Clife%E2%80%9D%20dynamics%2C%20but%20still).

- Nautilus Magazine – _“In the Beginning, There Was Computation”_ by B. Agüera y Arcas (2024), which discusses the BFF experiment in accessible terms[nautil.us](https://nautil.us/in-the-beginning-there-was-computation-787023/#:~:text=lineages%20to%20the%20original%20,of%20its%20original%20architecture%20indefinitely)[nautil.us](https://nautil.us/in-the-beginning-there-was-computation-787023/#:~:text=There%20are%20irreducible%20requirements%2C%20though%3A,%E2%80%9D).

- CuBFF GitHub Repository – _“paradigms-of-intelligence/cubff”_ (2024). Open-source code for the BFF experiment, including Brainfuck, Forth, and other variants[github.com](https://github.com/paradigms-of-intelligence/cubff#:~:text=CuBFF).

## Citations

[![EmergentMind](https://www.google.com/s2/favicons?domain=https://www.emergentmind.com&sz=32) Computational Life: Emergence of Self-Replicators https://www.emergentmind.com/papers/2406.19108](https://www.emergentmind.com/papers/2406.19108#:~:text=,replication%20even%20in%20deterministic%20settings)
[![GitHub](https://www.google.com/s2/favicons?domain=https://github.com&sz=32) paradigms-of-intelligence/cubff](https://github.com/paradigms-of-intelligence/cubff#:~:text=This%20project%20provides%20a%20,were%20done%20using%20this%20code)
[![arXiv](https://www.google.com/s2/favicons?domain=https://arxiv.org&sz=32) https://arxiv.org/pdf/2406.19108?](https://arxiv.org/pdf/2406.19108?#:~:text=The%20code%20for%20the%20experiments,lang%20bff_noheads)
[![arXiv](https://www.google.com/s2/favicons?domain=https://arxiv.org&sz=32) https://arxiv.org/pdf/2406.19108?](https://arxiv.org/pdf/2406.19108?#:~:text=detail%2C%20we%20release%20its%20code,for%20a%20different%20programming%20language)
[![arXiv](https://www.google.com/s2/favicons?domain=https://arxiv.org&sz=32) https://arxiv.org/pdf/2406.19108?](https://arxiv.org/pdf/2406.19108?#:~:text=computation%20increases%20a%20replicator%E2%80%99s%20allotted,into%20%E2%80%9Clife%E2%80%9D%20dynamics%2C%20but%20still)
[![arXiv](https://www.google.com/s2/favicons?domain=https://arxiv.org&sz=32) https://arxiv.org/pdf/2406.19108?](https://arxiv.org/pdf/2406.19108?#:~:text=a%20very%20simple%20solution%20involves,is%20explicitly%20disallowed%20by%20constraint)
[![EmergentMind](https://www.google.com/s2/favicons?domain=https://www.emergentmind.com&sz=32) Computational Life: Emergence of Self-Replicators https://www.emergentmind.com/papers/2406.19108](https://www.emergentmind.com/papers/2406.19108#:~:text=behaviors%20even%20without%20predefined%20fitness,of%20evolving%20complex%20behaviors%20autonomously)
[![EmergentMind](https://www.google.com/s2/favicons?domain=https://www.emergentmind.com&sz=32) Computational Life: Emergence of Self-Replicators https://www.emergentmind.com/papers/2406.19108](https://www.emergentmind.com/papers/2406.19108#:~:text=elements%20play%20a%20crucial%20role,still%20achieve%20significant%20evolutionary%20dynamics)
